## 1. 開発環境セットアップ

1. **リポジトリ作成**

   ```
   python/
   ├─ app/           # FastAPI サービス
   ├─ research/      # LangGraph 定義
   ├─ tests/
   ├─ Dockerfile
   └─ docker-compose.yml
   ```
2. **Python & Poetry**

   * Python 3.11 をインストール
   * `poetry init` で依存管理開始
3. **依存ライブラリ追加**

   ```bash
   poetry add fastapi uvicorn[standard] python-dotenv
   poetry add geopy aiohttp redis asyncio
   poetry add langgraph langchain_google_genai
   poetry add pydantic-settings
   poetry add pytest pytest-asyncio httpx --group dev
   ```
4. **Dockerfile / docker-compose**

   * マルチステージで軽量化
   * `REDIS_URL`, `GOOGLE_API_KEY`, `GEMINI_API_KEY` を環境変数で注入

### 確認項目 ✅

* [ ] `poetry install && poetry run uvicorn app.main:app` でローカル起動成功
* [ ] `docker compose up` で FastAPI + Redis が立ち上がる
* [ ] `http://localhost:8000/docs` が表示される

---

## 2. コンフィグ & 共通モジュール

1. **`config.py`**

   * `Pydantic BaseSettings` で環境変数をラップ
   * `MAX_CONCURRENT_RESEARCH`, `RESEARCH_TIMEOUT_SECONDS` などを定義
2. **エラーハンドラ**

   * FastAPI の `exception_handler` で共通 JSON 形式を返却
3. **ユーティリティ**

   * `distance.py` に `geodesic_distance_m(lat1, lon1, lat2, lon2)`
   * 列挙型 `ActivityType`, `BudgetRange` を `enums.py` に実装

### 確認項目 ✅

* [ ] `.env.example` が整備され、秘密情報は含まれていない
* [ ] 構成値を書き換えて再起動し、反映が確認できる
* [ ] テストで距離計算が仕様の範囲(±1 m)に収まる

---

## 3. Pydantic モデル & バリデーション

1. **`schemas/request.py`**

   * 仕様書の JSON を忠実にクラス化
   * カスタム validator で緯度経度の桁数丸め・範囲チェック
2. **`schemas/response.py`**

   * `status_update`, `research_update` などの SSE イベント用モデル
3. **自動テスト**

   * 境界値（範囲外緯度, 列挙外値）で `400` になることを確認

### 確認項目 ✅

* [ ] 正常系リクエストで 200、異常系で 400 が返る
* [ ] `pytest -q` がグリーン

---

## 4. エンドポイント実装 `/recommendations/stream`

1. **SSE ストリーム基盤**

   * `fastapi.responses.EventSourceResponse` を利用
2. **非同期ワークフロー起動**

   * `Coordinator` を `asyncio.create_task` で実行し、ステータスを queue に送信
3. **キャンセル／タイムアウト**

   * overall で `asyncio.wait_for`、駅単位で `Research Timeout` 使用

### 確認項目 ✅

* [ ] cURL / Swagger でヘッダ `Accept: text/event-stream` を付けて受信可能
* [ ] `stream_end` イベントが確実に送出される
* [ ] タイムアウト時に `504` を返す

---

## 5. Coordinator 実装

1. **駅候補検索**

   * Google Places Text Search (`type=train_station`)
   * `search_radius_km`, `max_stations` 適用
2. **大都市リスト近傍検索**

   * 49駅リストをロードし、距離昇順で最小1駅選択
3. **重複排除 & 正規化**

   * 駅名を全角/半角・大小無視で比較
4. **並列 Station Research Graph 起動**

   * `asyncio.Semaphore(MAX_CONCURRENT_RESEARCH)`
   * 各駅ごとに個別タスクを生成

### 確認項目 ✅

* [ ] debug ログに最終駅リストが想定件数以内で出力
* [ ] Places API エラー時にフォールバックが動作
* [ ] セマフォ設定を変更しベンチマーク、同時実行数が守られる

---

## 6. Station Research Graph (LangGraph)

1. **状態クラス `StationResearchState`** を作成
2. **ツールラッパ実装**

   ```python
   async def google_places_search_tool(query: str) -> list[dict]:
       ...
   ```
3. **ノード実装**

   * `query_generator_node`, `search_executor_node`, `critique_node`, `summary_generator_node`
   * 各ノードで Gemini 呼び出し
4. **エッジ定義 (`should_continue_edge`)**

   * `critique_node` の出力が `"COMPLETE"` で分岐
5. **Graph テスト**

   * LangGraph の `simulate` でモック検索を通し、1サイクルで COMPLETE になるパスを確認

### 確認項目 ✅

* [ ] 3クエリ生成 → 検索 → クリティーク → COMPLETE の流れが 1 駅で成功
* [ ] OPENAI / Gemini への API コール回数が抑制されている（リトライ含む統計取得）
* [ ] タイムアウトで Graph が中断し、`status = partial` になるケースが網羅テスト済み

---

## 7. Final Aggregator Agent

1. **駅別サマリー収集**

   * 完了したタスクから `summary` を取得
2. **ランキング生成**

   * Gemini に最終プロンプトを投げ、`overall_score` を算出
3. **SSE `final_report`**

   * JSON スキーマを検証して送出

### 確認項目 ✅

* [ ] 少なくとも 1 駅成功時、`status = complete/partial` の切替が正しい
* [ ] `research_quality` = 成功駅 / 総駅 が小数点1桁で返る
* [ ] レスポンス JSON がフロントでパース可能（スキーマバリデーション通過）

---

## 8. キャッシュ層（Redis）

1. **Deep Research キャッシュ**

   * Key: `station:{hash}`、TTL 1 hour
2. **最終結果キャッシュ**

   * Key: `req:{body_hash}`、TTL 30 min
3. **ミドルウェア化**

   * 検索前後でキャッシュ hit/put するデコレーター

### 確認項目 ✅

* [ ] 同一リクエストを 2回実行し 2回目は外部 API コール数ゼロ
* [ ] TTL 経過後に再度コールされることを確認

---

## 9. エラーハンドリング & ロギング

1. **構造化ログ** (`structlog` 推奨)

   * `request_id` を全ログに付与
2. **外部 API 障害時**

   * 仕様書の HTTP コード・`error_code` を統一
3. **アラート**

   * `5xx` 比率閾値で Slack 通知を設定

### 確認項目 ✅

* [ ] テストで各種例外を発生させ、期待通りのレスポンスボディが返る
* [ ] CloudWatch / Grafana 等でメトリクスが可視化される

---

## 10. セキュリティ & レートリミット

1. **API Key 認証**

   * `X-API-KEY` ヘッダ必須化、Redis で回数制限
2. **CORS & CSRF**

   * `fastapi.middleware.cors` で許可ドメイン限定
3. **依存性スキャン**

   * `poetry export --with=dev -f requirements.txt | safety check`

### 確認項目 ✅

* [ ] API Key 無しの場合 401 が返る
* [ ] 1 分あたりのリクエスト上限超過で 429 が返る
* [ ] SCA レポートで High Severity がゼロ

---

## 11. 自動テスト & CI

1. **ユニットテスト** (`pytest`, `pytest-asyncio`)
2. **E2E テスト**

   * `httpx.AsyncClient` でストリームを検証
3. **GitHub Actions**

   * PR 時に `pytest`, `flake8`, `black --check` を実行

### 確認項目 ✅

* [ ] CI が fail なく通過
* [ ] テストカバレッジ 80 %以上

---

## 12. デプロイ & 運用

1. **Docker イメージビルド**

   * `docker build --platform linux/amd64`
2. **本番環境（例: ECS/Fargate or GKE）へのデプロイ**

   * Secrets Manager で環境変数を注入
3. **Blue-Green or Canary**

   * 5 % トラフィック → 100 % 切替

### 確認項目 ✅

* [ ] 本番ログで SSE が途切れず配信されている
* [ ] ロールバック手順書が整備されている
* [ ] ダッシュボードで CPU / RTT が正常範囲

---

## 13. リリース後チェックリスト

| チェック                   | OK | 備考 |
| ---------------------- | -- | -- |
| 24 時間以内のエラーレート < 0.1 % |    |    |
| 平均応答時間 < 1500 ms       |    |    |
| キャッシュヒット率 > 60 %       |    |    |
| Gemini 月間使用量 予算内       |    |    |

---

💡 **ヒント**

* LangGraph のノードごとに **unit test + prompt example** を残しておくと LLM の挙動変動に強くなります。
* Redis ダウン時の挙動をローカルで再現 → 無停止を実機で確認しておくと安心です。

以上で実装手順書は完了です。各ステップで **確認項目をすべてクリア** してから次に進んでください。
